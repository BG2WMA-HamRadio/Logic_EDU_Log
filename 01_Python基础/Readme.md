### Python 基础中几个容易出现理解偏差的地方

#### 1. 关于`fn`和`fn()`:

- 教材或者课程上提到的`fn`是**函数对象**，`fn()`是**函数调用**，在理解上还是出现混淆。
- 如果需要将函数的代码（函数对象）返回到被嵌套的函数外边来运行，就`return fn`，运行到这段代码的时候要添加`()`表示调用。多数函数需要在`()`中传递参数。
- 如果没有在被嵌套函数外部调用的需要，则`return fn()`，直接将运行的结果传递出来，这样也就没有必要对返回的结果另行赋值了。
- 用一段代码做个说明就会理解的清楚些。
```
def fn():
    def fn2():
        print('python'.title())
    return fn2()      # 这种方式相当于直接调用（运行）了'fn2()'这个函数，并不会返回fn2()这个函数。

r = fn()              # 这行语句其实是有问题的，这里即使将前边的'r ='去掉，仍然会将'fn2()'的结果 'Python' 输出出来。
                      # 这也就不难理解为何下边的语句会出现一个空值'None'了。
print(r)              # 这里显示'None'，说明 'r' 的结果是空值，也就是说，'return'语句实质上并没有给 'r' 赋值。
```
- 上边这段代码里，在`return fn2()`这里，实际上`fn2()`这个函数已经运行了，所以`return`返回的是一个空值。  

```

def fn():
    def fn2():
        print('python'.upper())
    return fn2       # 将函数作为结果返回，在这里并没有执行（调用）该函数

r = fn()             # 这一步并没有任何的输出显示。
print(r)             # '<function fn.<locals>.fn2 at 0x0000028D0E5451F0>' 说明这个时候 'r' 得到了一个函数。
r()                  # PYTHON, 'r()'相当于运行（调用）函数fn()中的fn2()，从而得到运行fn2()函数的结果。

```
- 我们实际需要的是让`r`得到一个`fn2()`的整个运行代码，也就是所谓的**函数对象**。  
- `return fn2`实现了这个目的。后期程序需要调用`r()`的时候就不会得到一个错误的`None`值。

#### 关于汉诺塔游戏解法的Python实现：
- 既然你已经看到这篇文章，说明你肯定对汉诺塔游戏并不陌生，如果陌生 ———— 到处都是。
- 我个人认为理解这个解法的难点，并非是能够分析到将`第n-1`个盘子移动到 `缓冲`柱子上。而是去确定到底那根柱子是缓冲柱。
- 所以，解决这个问题的关键并不是对递归函数的理解，而是对`全局变量`和`局部变量`的理解。

- 先写一下过程，再逐条语句去分析一下解题思路。
```
# 用递归函数解决汉诺塔游戏
def hnt(n, a, b, c):
    if n == 1:
        print('将第', n, '个盘子从', a, '移动到'， c)
        
    else:
        hnt(n-1, a, c, b)
        print('将第', n, '个盘子从', a, '移动到'， c)
        hnt(n-1, b, a, c)
        
hnt
        

```
