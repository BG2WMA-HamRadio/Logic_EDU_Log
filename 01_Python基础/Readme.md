### 面向对象的三大特性
  - 1. 封装：确保对象中的数据安全
  - 2. 继承：保证了对象的可扩展性
  - 3. 多态：保证了对象的灵活性

### PyCharm无法import的解决方法
- 在PyCharm中正常创建的文件，无法通过import作为模块导入。
- 首先，新建项目文件夹时，确保使用`Python Package`模式。
- 在项目文件夹**根目录**中，创建一个include目录，来存放被导入的模块（.py文件）。
- 在PyCharm的右侧导航栏中，导航到include目录，右键单击。
- 在弹出菜单中，导航到`Mark Dircetory as` --> `Sources Root`。
- 即时就可以导入include目录中的模块了。


### 关于`fn`和`fn()`:

- 教材或者课程上提到的`fn`是**函数对象**，`fn()`是**函数调用**，在理解上还是出现混淆。
- 如果需要将函数的代码（函数对象）返回到被嵌套的函数外边来运行，就`return fn`，运行到这段代码的时候要添加`()`表示调用。多数函数需要在`()`中传递参数。
- 如果没有在被嵌套函数外部调用的需要，则`return fn()`，直接将运行的结果传递出来，这样也就没有必要对返回的结果另行赋值了。
- 用一段代码做个说明就会理解的清楚些。
```
def fn():
    def fn2():
        print('python'.title())
    return fn2()      # 这种方式相当于直接调用（运行）了'fn2()'这个函数，并不会返回fn2()这个函数。

r = fn()              # 这行语句其实是有问题的，这里即使将前边的'r ='去掉，仍然会将'fn2()'的结果 'Python' 输出出来。
                      # 这也就不难理解为何下边的语句会出现一个空值'None'了。
print(r)              # 这里显示'None'，说明 'r' 的结果是空值，也就是说，'return'语句实质上并没有给 'r' 赋值。
```
- 上边这段代码里，在`return fn2()`这里，实际上`fn2()`这个函数已经运行了，所以`return`返回的是一个空值。  

```

def fn():
    def fn2():
        print('python'.upper())
    return fn2       # 将函数作为结果返回，在这里并没有执行（调用）该函数

r = fn()             # 这一步并没有任何的输出显示。
print(r)             # '<function fn.<locals>.fn2 at 0x0000028D0E5451F0>' 说明这个时候 'r' 得到了一个函数。
r()                  # PYTHON, 'r()'相当于运行（调用）函数fn()中的fn2()，从而得到运行fn2()函数的结果。

```
- 我们实际需要的是让`r`得到一个`fn2()`的整个运行代码，也就是所谓的**函数对象**。  
- `return fn2`实现了这个目的。后期程序需要调用`r()`的时候就不会得到一个错误的`None`值。

### 关于汉诺塔游戏解法的Python实现：
- 既然你已经看到这篇文章，说明你肯定对汉诺塔游戏并不陌生，如果陌生 ———— 到处都是。
- 我个人认为理解这个解法的难点，并非是能够分析到将`第n-1`个盘子移动到 `缓冲`柱子上。而是去确定到底那根柱子是缓冲柱。
- 所以，解决这个问题的关键并不是对递归函数的理解，而是对`位置参数`的理解。

- 先写一下过程，再逐条语句去分析一下解题思路。
```
# 用递归函数解决汉诺塔游戏
def hnt(n, a, b, c):
    if n == 1:
        print('将第', n, '个盘子从', a, '移动到', c)
        
    else:
        hnt(n-1, a, c, b)
        print('将第', n, '个盘子从', a, '移动到', c)
        hnt(n-1, b, a, c)
        
hnt(5, 'A柱', 'B柱', 'C柱')
```
- `hnt(5, 'A柱', 'B柱', 'C柱')` 调用hnt函数并向函数的形参传递实参。
  - 第一个实参5，说明我们准备移动5个盘子（这是废话）。
  - 后边三个柱子，依次**按位置**对应到a, b, c, 三个形参。整个程序里的`a = A柱`，`b = B柱`，`c = c柱`。
- `def hnt(n, a, b, c)`，定义一个函数hnt()，并定义了4个参数，n个盘子，以及abc三根柱子。分别对应`位置1`，`位置2`，`位置3`
    - 注意，整个程序没有用到关键字参数，所有参数都是位置参数。
- `if n == 1: print('将第', n, '个盘子从', a, '移动到', c)`
  - 这行语句是递归函数的**基线条件**：当`第一根柱子上`只有一个盘子的时候，把唯一的盘子从`a`移动到`c`。
  - 注意，我没有写从`A柱`移动到`C柱`。而应该是将盘子从`位置1`移动到`位置3`，只不过这时候恰好`位置1`对应到`A柱`，`位置3`对应到`C柱`
  - 仔细观察，整个程序都是在打印这一行话：从`位置1`移动到`位置3`。
  
- `else:` 如果`第一根柱子上`盘子的数量多余1个，我们要进行的步骤。
  - 从这条语句开始，进入了递归函数的**递归条件**，解决`(n - 1)`的问题。
  - 也是从这条语句开始，我们的柱子的排列顺序变了。也就是说，在解决这个问题的时候，不光盘子是可以移动的，**柱子也是可以移动的**。
  - 递归语句中用了三个步骤，
- `hnt(n-1, a, c, b)`，将n-1个盘子移动到**第二根**柱子上。
  - 这里注意理解一下第二根柱子和`位置2`的区别。
  - 这个时候，`位置2`对应到了`C柱`，`位置3`对应到了`B柱`。实际上是**将盘子从`位置1`移动到`位置3`**
- `位置1`的柱子上只有一个`n`盘，**将盘子从`位置1`移动到`位置3`**
- `hnt(n-1, b, a, c)`,然后将n-1个盘子从**第二根**柱子上移动到**第三根**柱子上。
  - 同样，注意理解柱子名称和柱子编号的关系
  - 程序执行的结果还是**将盘子从`位置1`移动到`位置3`**
  - 理解了上述过程以后，再参照对递归函数的理解，就不难得到正确的思路了。
  
